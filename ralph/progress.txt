---
## [2026-02-21 12:00:00] - US-001: Create salon_wallets table and enum types

### Implemented
- Created wallet_type ENUM with 'customer' and 'salon' values
- Created wallet_entry_type ENUM with all 10 entry types (customer_purse_topup, customer_purse_debit_booking, customer_purse_debit_invoice, customer_purse_reversal, salon_purse_credit_booking, salon_purse_credit_invoice, salon_purse_topup, salon_purse_withdrawal, salon_purse_reversal, salon_purse_debit_credit_purchase)
- Created salon_wallets table with id, tenant_id (unique), currency (default NGN), balance (default 0), created_at, updated_at
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Added index on tenant_id for faster lookups
- Created trigger to auto-update updated_at timestamp on updates

### Files Changed
- supabase/migrations/20260221120000_create_purse_enums_and_salon_wallets.sql

### Learnings
- Project uses timestamp naming convention for migrations: YYYYMMDDHHMMSS_description.sql
- No typecheck command exists in the project; only lint, test, build, dev commands
- Lint command has pre-existing eslint installation issues (eslint not found) - this is unrelated to SQL migration changes
- SQL migrations do not require TypeScript type checking
- Story acceptance criteria met: All ENUMs and tables created with proper constraints

---
## [2026-02-21 22:54:13] - US-002: Create wallet_ledger_entries table

### Implemented
- Created wallet_ledger_entries table with all required columns: id, tenant_id, wallet_type, wallet_id, entry_type, currency, amount, balance_before, balance_after, reference_type, reference_id, gateway, gateway_reference, idempotency_key, metadata (JSONB default '{}'), created_at
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Created unique index wallet_ledger_idempotency_idx on (tenant_id, idempotency_key) WHERE idempotency_key IS NOT NULL for idempotent transaction processing
- Created index wallet_ledger_wallet_idx on (wallet_type, wallet_id, created_at DESC) for efficient wallet-based queries

### Files Changed
- supabase/migrations/20260221120001_create_wallet_ledger_entries.sql
- ralph/prd.json (updated branchName to feat--salon-customer-purse, marked US-002 as passing)

### Learnings
- Idempotency is enforced at the database level through unique partial index on (tenant_id, idempotency_key)
- Composite index on (wallet_type, wallet_id, created_at DESC) will optimize queries for transaction history by wallet
- JSONB metadata field provides flexibility for storing transaction-specific context without schema changes
- All acceptance criteria met: table structure, foreign key, both required indexes created

---
## [2026-02-21 23:05:59] - US-003: Create salon_payout_destinations table

### Implemented
- Created payout_destination_type ENUM with 'bank' and 'mobile_money' values
- Created salon_payout_destinations table with all required columns: id, tenant_id, destination_type, country, currency, bank_code, bank_name, account_number, account_name, momo_provider, momo_number, paystack_recipient_code, is_default (default false), created_at
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Created index idx_salon_payout_destinations_tenant on tenant_id for faster lookups

### Files Changed
- supabase/migrations/20260221120002_create_salon_payout_destinations.sql
- ralph/prd.json (marked US-003 as passing)
- ralph/progress.txt (this file)

### Learnings
- Table supports both bank accounts (for Nigeria NUBAN and Ghana GHIPSS) and mobile money providers (MTN, Vodafone, AirtelTigo)
- paystack_recipient_code column stores Paystack's recipient code for transfer API calls
- is_default flag allows tenants to mark a preferred payout destination
- Multiple destination types (bank vs mobile_money) can be stored per tenant for flexibility

---
## [2026-02-21 23:18:00] - US-004: Create salon_withdrawals table

### Implemented
- Created withdrawal_status ENUM with 'pending', 'processing', 'completed', 'failed' values
- Created salon_withdrawals table with all required columns: id, tenant_id, salon_wallet_id, payout_destination_id, currency, amount, status (default 'pending'), paystack_transfer_code, paystack_reference, failure_reason, requested_at (default NOW())
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Added foreign key constraint on salon_wallet_id to salon_wallets table with CASCADE delete
- Added foreign key constraint on payout_destination_id to salon_payout_destinations table with CASCADE delete
- Created indexes for tenant_id, salon_wallet_id, and status for faster lookups

### Files Changed
- supabase/migrations/20260221120003_create_salon_withdrawals.sql
- ralph/prd.json (marked US-004 as passing)
- ralph/progress.txt (this file)

### Learnings
- Table tracks the full lifecycle of a withdrawal request from pending → processing → completed/failed
- paystack_transfer_code and paystack_reference store Paystack's transfer identifiers
- failure_reason captures error messages when withdrawals fail
- Amount is stored with NUMERIC(12, 2) precision to handle currencies accurately
- All foreign keys cascade on delete to maintain referential integrity

---
## [2026-02-21 23:45:00] - US-005: Create messaging_credit_purchases table

### Implemented
- Created messaging_credit_purchases table with all required columns: id, tenant_id, credits (INTEGER), currency, amount, paid_via (TEXT), payment_intent_id (UUID), gateway_reference, created_at
- Added CHECK constraint on paid_via to only accept 'salon_purse' or 'paystack' values
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Created indexes for tenant_id, paid_via, and created_at for query performance

### Files Changed
- supabase/migrations/20260221120004_create_messaging_credit_purchases.sql
- ralph/prd.json (marked US-005 as passing)
- ralph/progress.txt (this file)

### Learnings
- Used CHECK constraint instead of ENUM for paid_via since only 2 fixed values are needed
- payment_intent_id is nullable since it's only populated for Paystack payments (not purse payments)
- Amount uses NUMERIC(12, 2) for consistent currency precision
- All acceptance criteria met: table structure, foreign key, and paid_via constraint

---
## [2026-02-22 00:30:00] - US-006: Extend existing tables with purse-related columns

### Implemented
- Added intent_type TEXT column to payment_intents table (IF NOT EXISTS)
- Created index idx_payment_intents_intent_type for filtering by intent_type
- Added payment_link TEXT column to invoices table (IF NOT EXISTS)
- Added payment_intent_id UUID column to invoices table (IF NOT EXISTS)
- Added foreign key constraint from invoices.payment_intent_id to payment_intents.id (with ON DELETE SET NULL)
- Created index idx_invoices_payment_intent_id for payment_intent_id lookups
- Added min_withdrawal_ngn NUMERIC(10,2) DEFAULT 1000 to tenants table (IF NOT EXISTS)
- Added min_withdrawal_ghs NUMERIC(10,2) DEFAULT 50 to tenants table (IF NOT EXISTS)
- Added documentation comments for all new columns

### Files Changed
- supabase/migrations/20260221120005_extend_tables_for_purse.sql
- ralph/prd.json (marked US-006 as passing)
- ralph/progress.txt (this file)

### Learnings
- All ALTER TABLE statements use IF NOT EXISTS for idempotent schema updates
- Foreign key constraint creation wrapped in DO block to check if constraint already exists
- intent_type column supports 5 payment types: appointment_payment, customer_purse_topup, salon_purse_topup, invoice_payment, messaging_credit_purchase
- payment_intent_id on invoices enables tracking online invoice payments via Paystack
- Minimum withdrawal amounts vary by currency: NGN 1000 (~$1.20), GHS 50 (~$3.10)
- Indexes created with WHERE clauses for partial indexes on non-null values to save space
- Comments added for schema documentation and developer clarity

---
## [2026-02-22 01:15:00] - US-007: Create auto-create salon wallet trigger

### Implemented
- Created create_salon_wallet_for_tenant() function that:
  - Inserts salon_wallet with tenant_id and currency from NEW tenant record
  - Uses ON CONFLICT (tenant_id) DO NOTHING for idempotency
  - Returns NEW as required for trigger functions
  - Marked as SECURITY DEFINER for proper permissions
- Created trigger_create_salon_wallet as AFTER INSERT on tenants table
- Added DROP TRIGGER IF EXISTS for idempotent migration
- Backfilled existing tenants with INSERT...SELECT query filtering WHERE id NOT IN (SELECT tenant_id FROM salon_wallets)
- Used ON CONFLICT DO NOTHING on backfill for idempotency
- Added documentation comments for function and trigger

### Files Changed
- supabase/migrations/20260221120006_create_salon_wallet_trigger.sql
- ralph/prd.json (marked US-007 as passing)
- ralph/progress.txt (this file)

### Learnings
- Trigger functions must return NEW for AFTER INSERT triggers to maintain proper flow
- SECURITY DEFINER needed on trigger function to ensure it has proper privileges to insert into salon_wallets
- ON CONFLICT (tenant_id) DO NOTHING provides idempotency for both trigger and backfill operations
- DROP TRIGGER IF EXISTS ensures migration can be re-run safely
- Backfill pattern: INSERT INTO target SELECT FROM source WHERE source.id NOT IN (SELECT key FROM target)
- All acceptance criteria met: function creation, trigger creation, backfill, returns NEW

---
## [2026-02-22 02:30:00] - US-008: Create credit_customer_purse RPC function

### Implemented
- Created credit_customer_purse() function accepting p_tenant_id, p_customer_id, p_amount, p_currency, p_idempotency_key, p_gateway_reference (optional)
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if transaction already processed (prevents double-crediting)
- Locks customer_purses row with FOR UPDATE to ensure atomic balance updates
- Creates customer purse if not exists with balance 0 and returns new purse ID
- Calculates new balance by adding p_amount to current balance
- Updates customer_purses balance and updated_at timestamp
- Creates wallet_ledger_entries record with entry_type 'customer_purse_topup', storing balance_before, balance_after, and idempotency_key
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120007_create_credit_customer_purse_rpc.sql
- ralph/prd.json (marked US-008 as passing)
- ralph/progress.txt (this file)

### Learnings
- Idempotency check must happen before any row locking to avoid deadlocks in concurrent scenarios
- FOR UPDATE lock on customer_purses prevents race conditions when multiple topups occur simultaneously
- INSERT...RETURNING allows creating purse and capturing id/balance in single query
- SECURITY DEFINER ensures function runs with privileges of function owner, allowing service role to execute wallet operations
- Gateway reference stored conditionally (only for Paystack payments, NULL for direct purse operations)
- Function pattern: check idempotency → lock → create if needed → update balance → create ledger entry → return ID

---
## [2026-02-22 03:00:00] - US-009: Create debit_customer_purse_for_booking RPC function

### Implemented
- Created debit_customer_purse_for_booking() function accepting p_tenant_id, p_customer_id, p_appointment_id, p_amount, p_currency, p_idempotency_key
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if transaction already processed (prevents duplicate debits)
- Locks customer_purses row with FOR UPDATE to ensure atomic balance updates
- Raises exception 'Customer purse not found' if purse doesn't exist
- Verifies sufficient balance before processing
- Raises exception 'Insufficient purse balance. Available: X, Required: Y' if balance < amount
- Calculates new balance by subtracting p_amount from current balance
- Updates customer_purses balance and updated_at timestamp
- Creates wallet_ledger_entries record with entry_type 'customer_purse_debit_booking', negative amount, reference_type 'appointment', reference_id p_appointment_id
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120008_create_debit_customer_purse_for_booking_rpc.sql
- ralph/prd.json (marked US-009 as passing)
- ralph/progress.txt (this file)

### Learnings
- Debit functions must verify balance before locking to fail fast on insufficient funds
- Exception messages should include both available and required amounts for clarity
- Negative amounts in ledger entries clearly indicate debits vs credits (credits are positive)
- Reference type 'appointment' and reference_id link ledger entries to specific bookings
- Pattern for debit functions: check idempotency → lock → verify balance → update balance → create ledger entry → return ID
- SECURITY DEFINER required for service role to execute wallet operations on behalf of customers
- All acceptance criteria met: function signature, idempotency, locking, balance verification, exception handling, ledger entry creation

