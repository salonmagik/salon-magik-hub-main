---
## [2026-02-21 12:00:00] - US-001: Create salon_wallets table and enum types

### Implemented
- Created wallet_type ENUM with 'customer' and 'salon' values
- Created wallet_entry_type ENUM with all 10 entry types (customer_purse_topup, customer_purse_debit_booking, customer_purse_debit_invoice, customer_purse_reversal, salon_purse_credit_booking, salon_purse_credit_invoice, salon_purse_topup, salon_purse_withdrawal, salon_purse_reversal, salon_purse_debit_credit_purchase)
- Created salon_wallets table with id, tenant_id (unique), currency (default NGN), balance (default 0), created_at, updated_at
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Added index on tenant_id for faster lookups
- Created trigger to auto-update updated_at timestamp on updates

### Files Changed
- supabase/migrations/20260221120000_create_purse_enums_and_salon_wallets.sql

### Learnings
- Project uses timestamp naming convention for migrations: YYYYMMDDHHMMSS_description.sql
- No typecheck command exists in the project; only lint, test, build, dev commands
- Lint command has pre-existing eslint installation issues (eslint not found) - this is unrelated to SQL migration changes
- SQL migrations do not require TypeScript type checking
- Story acceptance criteria met: All ENUMs and tables created with proper constraints

---
## [2026-02-21 22:54:13] - US-002: Create wallet_ledger_entries table

### Implemented
- Created wallet_ledger_entries table with all required columns: id, tenant_id, wallet_type, wallet_id, entry_type, currency, amount, balance_before, balance_after, reference_type, reference_id, gateway, gateway_reference, idempotency_key, metadata (JSONB default '{}'), created_at
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Created unique index wallet_ledger_idempotency_idx on (tenant_id, idempotency_key) WHERE idempotency_key IS NOT NULL for idempotent transaction processing
- Created index wallet_ledger_wallet_idx on (wallet_type, wallet_id, created_at DESC) for efficient wallet-based queries

### Files Changed
- supabase/migrations/20260221120001_create_wallet_ledger_entries.sql
- ralph/prd.json (updated branchName to feat--salon-customer-purse, marked US-002 as passing)

### Learnings
- Idempotency is enforced at the database level through unique partial index on (tenant_id, idempotency_key)
- Composite index on (wallet_type, wallet_id, created_at DESC) will optimize queries for transaction history by wallet
- JSONB metadata field provides flexibility for storing transaction-specific context without schema changes
- All acceptance criteria met: table structure, foreign key, both required indexes created

---
## [2026-02-21 23:05:59] - US-003: Create salon_payout_destinations table

### Implemented
- Created payout_destination_type ENUM with 'bank' and 'mobile_money' values
- Created salon_payout_destinations table with all required columns: id, tenant_id, destination_type, country, currency, bank_code, bank_name, account_number, account_name, momo_provider, momo_number, paystack_recipient_code, is_default (default false), created_at
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Created index idx_salon_payout_destinations_tenant on tenant_id for faster lookups

### Files Changed
- supabase/migrations/20260221120002_create_salon_payout_destinations.sql
- ralph/prd.json (marked US-003 as passing)
- ralph/progress.txt (this file)

### Learnings
- Table supports both bank accounts (for Nigeria NUBAN and Ghana GHIPSS) and mobile money providers (MTN, Vodafone, AirtelTigo)
- paystack_recipient_code column stores Paystack's recipient code for transfer API calls
- is_default flag allows tenants to mark a preferred payout destination
- Multiple destination types (bank vs mobile_money) can be stored per tenant for flexibility

---
## [2026-02-21 23:18:00] - US-004: Create salon_withdrawals table

### Implemented
- Created withdrawal_status ENUM with 'pending', 'processing', 'completed', 'failed' values
- Created salon_withdrawals table with all required columns: id, tenant_id, salon_wallet_id, payout_destination_id, currency, amount, status (default 'pending'), paystack_transfer_code, paystack_reference, failure_reason, requested_at (default NOW())
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Added foreign key constraint on salon_wallet_id to salon_wallets table with CASCADE delete
- Added foreign key constraint on payout_destination_id to salon_payout_destinations table with CASCADE delete
- Created indexes for tenant_id, salon_wallet_id, and status for faster lookups

### Files Changed
- supabase/migrations/20260221120003_create_salon_withdrawals.sql
- ralph/prd.json (marked US-004 as passing)
- ralph/progress.txt (this file)

### Learnings
- Table tracks the full lifecycle of a withdrawal request from pending → processing → completed/failed
- paystack_transfer_code and paystack_reference store Paystack's transfer identifiers
- failure_reason captures error messages when withdrawals fail
- Amount is stored with NUMERIC(12, 2) precision to handle currencies accurately
- All foreign keys cascade on delete to maintain referential integrity

---
## [2026-02-21 23:45:00] - US-005: Create messaging_credit_purchases table

### Implemented
- Created messaging_credit_purchases table with all required columns: id, tenant_id, credits (INTEGER), currency, amount, paid_via (TEXT), payment_intent_id (UUID), gateway_reference, created_at
- Added CHECK constraint on paid_via to only accept 'salon_purse' or 'paystack' values
- Added foreign key constraint on tenant_id to tenants table with CASCADE delete
- Created indexes for tenant_id, paid_via, and created_at for query performance

### Files Changed
- supabase/migrations/20260221120004_create_messaging_credit_purchases.sql
- ralph/prd.json (marked US-005 as passing)
- ralph/progress.txt (this file)

### Learnings
- Used CHECK constraint instead of ENUM for paid_via since only 2 fixed values are needed
- payment_intent_id is nullable since it's only populated for Paystack payments (not purse payments)
- Amount uses NUMERIC(12, 2) for consistent currency precision
- All acceptance criteria met: table structure, foreign key, and paid_via constraint

---
## [2026-02-22 00:30:00] - US-006: Extend existing tables with purse-related columns

### Implemented
- Added intent_type TEXT column to payment_intents table (IF NOT EXISTS)
- Created index idx_payment_intents_intent_type for filtering by intent_type
- Added payment_link TEXT column to invoices table (IF NOT EXISTS)
- Added payment_intent_id UUID column to invoices table (IF NOT EXISTS)
- Added foreign key constraint from invoices.payment_intent_id to payment_intents.id (with ON DELETE SET NULL)
- Created index idx_invoices_payment_intent_id for payment_intent_id lookups
- Added min_withdrawal_ngn NUMERIC(10,2) DEFAULT 1000 to tenants table (IF NOT EXISTS)
- Added min_withdrawal_ghs NUMERIC(10,2) DEFAULT 50 to tenants table (IF NOT EXISTS)
- Added documentation comments for all new columns

### Files Changed
- supabase/migrations/20260221120005_extend_tables_for_purse.sql
- ralph/prd.json (marked US-006 as passing)
- ralph/progress.txt (this file)

### Learnings
- All ALTER TABLE statements use IF NOT EXISTS for idempotent schema updates
- Foreign key constraint creation wrapped in DO block to check if constraint already exists
- intent_type column supports 5 payment types: appointment_payment, customer_purse_topup, salon_purse_topup, invoice_payment, messaging_credit_purchase
- payment_intent_id on invoices enables tracking online invoice payments via Paystack
- Minimum withdrawal amounts vary by currency: NGN 1000 (~$1.20), GHS 50 (~$3.10)
- Indexes created with WHERE clauses for partial indexes on non-null values to save space
- Comments added for schema documentation and developer clarity

---
## [2026-02-22 01:15:00] - US-007: Create auto-create salon wallet trigger

### Implemented
- Created create_salon_wallet_for_tenant() function that:
  - Inserts salon_wallet with tenant_id and currency from NEW tenant record
  - Uses ON CONFLICT (tenant_id) DO NOTHING for idempotency
  - Returns NEW as required for trigger functions
  - Marked as SECURITY DEFINER for proper permissions
- Created trigger_create_salon_wallet as AFTER INSERT on tenants table
- Added DROP TRIGGER IF EXISTS for idempotent migration
- Backfilled existing tenants with INSERT...SELECT query filtering WHERE id NOT IN (SELECT tenant_id FROM salon_wallets)
- Used ON CONFLICT DO NOTHING on backfill for idempotency
- Added documentation comments for function and trigger

### Files Changed
- supabase/migrations/20260221120006_create_salon_wallet_trigger.sql
- ralph/prd.json (marked US-007 as passing)
- ralph/progress.txt (this file)

### Learnings
- Trigger functions must return NEW for AFTER INSERT triggers to maintain proper flow
- SECURITY DEFINER needed on trigger function to ensure it has proper privileges to insert into salon_wallets
- ON CONFLICT (tenant_id) DO NOTHING provides idempotency for both trigger and backfill operations
- DROP TRIGGER IF EXISTS ensures migration can be re-run safely
- Backfill pattern: INSERT INTO target SELECT FROM source WHERE source.id NOT IN (SELECT key FROM target)
- All acceptance criteria met: function creation, trigger creation, backfill, returns NEW

---
## [2026-02-22 02:30:00] - US-008: Create credit_customer_purse RPC function

### Implemented
- Created credit_customer_purse() function accepting p_tenant_id, p_customer_id, p_amount, p_currency, p_idempotency_key, p_gateway_reference (optional)
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if transaction already processed (prevents double-crediting)
- Locks customer_purses row with FOR UPDATE to ensure atomic balance updates
- Creates customer purse if not exists with balance 0 and returns new purse ID
- Calculates new balance by adding p_amount to current balance
- Updates customer_purses balance and updated_at timestamp
- Creates wallet_ledger_entries record with entry_type 'customer_purse_topup', storing balance_before, balance_after, and idempotency_key
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120007_create_credit_customer_purse_rpc.sql
- ralph/prd.json (marked US-008 as passing)
- ralph/progress.txt (this file)

### Learnings
- Idempotency check must happen before any row locking to avoid deadlocks in concurrent scenarios
- FOR UPDATE lock on customer_purses prevents race conditions when multiple topups occur simultaneously
- INSERT...RETURNING allows creating purse and capturing id/balance in single query
- SECURITY DEFINER ensures function runs with privileges of function owner, allowing service role to execute wallet operations
- Gateway reference stored conditionally (only for Paystack payments, NULL for direct purse operations)
- Function pattern: check idempotency → lock → create if needed → update balance → create ledger entry → return ID

---
## [2026-02-22 03:00:00] - US-009: Create debit_customer_purse_for_booking RPC function

### Implemented
- Created debit_customer_purse_for_booking() function accepting p_tenant_id, p_customer_id, p_appointment_id, p_amount, p_currency, p_idempotency_key
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if transaction already processed (prevents duplicate debits)
- Locks customer_purses row with FOR UPDATE to ensure atomic balance updates
- Raises exception 'Customer purse not found' if purse doesn't exist
- Verifies sufficient balance before processing
- Raises exception 'Insufficient purse balance. Available: X, Required: Y' if balance < amount
- Calculates new balance by subtracting p_amount from current balance
- Updates customer_purses balance and updated_at timestamp
- Creates wallet_ledger_entries record with entry_type 'customer_purse_debit_booking', negative amount, reference_type 'appointment', reference_id p_appointment_id
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120008_create_debit_customer_purse_for_booking_rpc.sql
- ralph/prd.json (marked US-009 as passing)
- ralph/progress.txt (this file)

### Learnings
- Debit functions must verify balance before locking to fail fast on insufficient funds
- Exception messages should include both available and required amounts for clarity
- Negative amounts in ledger entries clearly indicate debits vs credits (credits are positive)
- Reference type 'appointment' and reference_id link ledger entries to specific bookings
- Pattern for debit functions: check idempotency → lock → verify balance → update balance → create ledger entry → return ID
- SECURITY DEFINER required for service role to execute wallet operations on behalf of customers
- All acceptance criteria met: function signature, idempotency, locking, balance verification, exception handling, ledger entry creation

---
## [2026-02-22 15:45:00] - US-010: Create credit_salon_purse RPC function

### Implemented
- Created credit_salon_purse() function accepting p_tenant_id, p_entry_type, p_reference_type, p_reference_id, p_amount, p_currency, p_idempotency_key, p_gateway_reference (optional)
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if transaction already processed (prevents double-crediting)
- Locks salon_wallets row with FOR UPDATE to ensure atomic balance updates
- Raises exception 'Salon wallet not found for tenant X' if wallet doesn't exist
- Calculates new balance by adding p_amount to current balance
- Updates salon_wallets balance and updated_at timestamp
- Creates wallet_ledger_entries record with provided p_entry_type (supports salon_purse_credit_booking, salon_purse_credit_invoice, salon_purse_topup)
- Stores reference_type and reference_id for traceability (e.g., 'appointment'/'invoice'/'topup' + respective ID)
- Conditionally sets gateway='paystack' when p_gateway_reference is provided
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120009_create_credit_salon_purse_rpc.sql
- ralph/prd.json (marked US-010 as passing)
- ralph/progress.txt (this file)

### Learnings
- Flexible entry_type parameter allows same function to handle multiple credit scenarios (booking payments, invoice payments, direct topups)
- Reference type and ID enable linking ledger entries to source transactions for audit trails
- Gateway reference is optional since salon credits can come from Paystack payments OR customer purse debits
- Function pattern mirrors credit_customer_purse: check idempotency → lock → verify existence → update balance → create ledger entry → return ID
- SECURITY DEFINER ensures edge functions can credit salon wallets on behalf of automated payment webhooks
- All acceptance criteria met: function signature with optional gateway_reference, idempotency, locking, exception on missing wallet, balance update, ledger entry creation with provided entry_type, returns ID

---
## [2026-02-22 16:30:00] - US-011: Create debit_salon_purse_for_withdrawal RPC function

### Implemented
- Created debit_salon_purse_for_withdrawal() function accepting p_tenant_id, p_withdrawal_id, p_amount, p_currency, p_idempotency_key
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if transaction already processed (prevents duplicate debits)
- Fetches minimum withdrawal amount from tenants table based on currency (NGN: min_withdrawal_ngn, GHS: min_withdrawal_ghs) with fallback defaults
- Raises exception if amount is below minimum with clear message showing amount and currency
- Locks salon_wallets row with FOR UPDATE to ensure atomic balance updates
- Raises exception 'Salon wallet not found for tenant X' if wallet doesn't exist
- Verifies sufficient balance before processing
- Raises exception 'Insufficient wallet balance. Available: X, Required: Y' if balance < amount
- Calculates new balance by subtracting p_amount from current balance
- Updates salon_wallets balance and updated_at timestamp
- Creates wallet_ledger_entries record with entry_type 'salon_purse_withdrawal', negative amount, reference_type 'withdrawal', reference_id p_withdrawal_id
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120010_create_debit_salon_purse_for_withdrawal_rpc.sql
- ralph/prd.json (marked US-011 as passing)
- ralph/progress.txt (this file)

### Learnings
- Minimum withdrawal amounts are currency-specific: NGN 1000 (~$1.20), GHS 50 (~$3.10)
- CASE statement used to dynamically select min_withdrawal based on currency
- COALESCE provides fallback defaults if min_withdrawal columns are NULL for any reason
- Exception messages include both currency symbol and amount for clarity to users
- Minimum amount check happens before wallet locking to fail fast and avoid unnecessary locks
- Pattern for withdrawal debits: check idempotency → validate minimum → lock → verify balance → update balance → create ledger entry → return ID
- All acceptance criteria met: function signature, idempotency, minimum withdrawal enforcement, wallet locking, balance verification, exception handling with descriptive messages, ledger entry creation with correct entry_type and negative amount
- Pre-existing build issues (marketing app dependency issue) and lint issues (eslint not found) unrelated to this SQL migration

---
## [2026-02-22 01:01:06] - US-012: Create create_wallet_reversal RPC function

### Implemented
- Created create_wallet_reversal() function accepting p_original_entry_id, p_reason, p_idempotency_key
- Function checks idempotency first by querying wallet_ledger_entries with idempotency_key
- Returns existing entry ID if reversal already processed (prevents duplicate reversals)
- Fetches original wallet_ledger_entries record to determine wallet type and retrieve transaction details
- Raises exception 'Original ledger entry not found with ID X' if original entry doesn't exist
- Determines reversal entry type based on wallet_type: customer → 'customer_purse_reversal', salon → 'salon_purse_reversal'
- Calculates reversal amount as negative of original amount (-1 * original.amount)
- For customer wallets: locks customer_purses row with FOR UPDATE, verifies purse exists, calculates new balance, updates balance
- For salon wallets: locks salon_wallets row with FOR UPDATE, verifies wallet exists, calculates new balance, updates balance
- Creates wallet_ledger_entries record with:
  - entry_type: customer_purse_reversal or salon_purse_reversal
  - amount: negative of original amount (reverses the transaction)
  - reference_type: 'reversal'
  - reference_id: original entry ID
  - metadata JSONB: contains reason, original_entry_id, original_amount, original_entry_type
- Returns ledger entry ID on success
- Marked as SECURITY DEFINER for proper permissions

### Files Changed
- supabase/migrations/20260222120011_create_wallet_reversal_rpc.sql
- ralph/prd.json (marked US-012 as passing)
- ralph/progress.txt (this file)

### Learnings
- Reversal functions must handle both customer and salon wallet types with conditional logic
- Reversal amount is calculated as -1 * original amount to undo the original transaction
- Metadata JSONB provides audit trail storing reason, original entry details for compliance and debugging
- FOR UPDATE locks prevent race conditions when multiple reversals might be attempted
- Function uses SELECT * INTO RECORD to fetch all columns from original entry efficiently
- Pattern for reversals: check idempotency → fetch original entry → validate existence → determine reversal type → lock wallet → calculate new balance → update balance → create reversal ledger entry → return ID
- All acceptance criteria met: function signature, idempotency, original entry fetch, exception handling, wallet type determination, wallet locking, reversal amount calculation, ledger entry creation with metadata
- Pre-existing lint issues (eslint not found) unrelated to this SQL migration

---
## [2026-02-22 03:30:00] - US-013: Extend create-payment-session edge function with intent_type

### Implemented
- Extended PaymentRequest interface to include:
  - intentType?: "appointment_payment" | "customer_purse_topup" | "salon_purse_topup" | "invoice_payment" | "messaging_credit_purchase"
  - customerId?: string
  - invoiceId?: string
  - credits?: number
- Made appointmentId optional since not all payment types require appointments (e.g., purse topups, invoice payments)
- Made isDeposit optional with default to false
- Updated validation to remove appointmentId requirement (now only tenantId, amount, customerEmail required)
- Updated reference generation to handle missing appointmentId gracefully
- Stored intent_type in payment_intents insert with default value 'appointment_payment'
- Added intent_type, customer_id, invoice_id, credits to Paystack metadata
- Added intent_type, customer_id, invoice_id, credits to Stripe metadata

### Files Changed
- supabase/functions/create-payment-session/index.ts
- ralph/prd.json (marked US-013 as passing)
- ralph/progress.txt (this file)

### Learnings
- Edge function now supports 5 payment intent types: appointment_payment, customer_purse_topup, salon_purse_topup, invoice_payment, messaging_credit_purchase
- appointmentId field made optional to accommodate non-appointment payment flows
- Metadata passed to both Paystack and Stripe includes all context fields needed for webhook processing
- intentType defaults to 'appointment_payment' for backward compatibility with existing clients
- No Deno installation available for typecheck, but TypeScript syntax verified manually
- All acceptance criteria met: optional fields added to interface, intentType with 5 values, default to 'appointment_payment', stored in DB, included in payment gateway metadata
